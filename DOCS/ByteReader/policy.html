<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>ByteReader</h1>




<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>bytereader</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>bytereader</code></h1>
<p>A <code>ByteReader</code> transforms Lua inputs adhering to a simple protocol into
 a bytes-count pair that other C and C++ APIs are able to safely consume.</p>
<p> The protocol goes as follows:</p>

<p> The object at index <code>arg</code> (in Lua state <code>L</code>) is examined.</p>

<p> If it happens to be a string, we can use its bytes and length directly.</p>

<p> Failing that, the object's metatable (if it has one) is queried for field
 <strong>__bytes</strong>. If no value is found, the object clearly does not honor the
 protocol, so we error out.</p>

<p> If <strong>__bytes</strong> is neither a light userdata nor a function, we have a
 garden-variety object and can use its bytes and length directly, as with strings.</p>

<p> When <strong>__bytes</strong> is a light userdata, it is assumed to point to a <code>ByteReaderFunc</code>
 struct, containing a reader function <code>mGetBytes</code> and a user-supplied context
 <code>mContext</code>. (The light userdata must also be present as a key in the Lua
 registry.) This is called as <code>mGetBytes(L, reader, arg, mContext)</code>, where
 <code>reader</code> is our byte reader, whose <strong>mBytes</strong> and <strong>mCount</strong> members the
 function should supply. (See below how to handle errors.)</p>

<p> The object in the foregoing cases must be a full userdata.</p>

<p> The remaining possibility is that <strong>__bytes</strong> is a function, to be called as</p>
<pre><code>object = func(object)
</code></pre>
<p> The process (i.e. is the object a string? if not, does it have a <strong>__bytes</strong>
 metafield? et al.) then recurses on this new object, using the final result.</p>

<p> When bytes are successfully found, the reader's <strong>mBytes</strong> member will point
 to them, with the byte count stored in <strong>mCount</strong>. If <code>bReplace</code> is <strong>true</strong>
 (the default), the final bytes object&mdash;either a string or full
 userdata&mdash;is moved into slot <code>arg</code>, overwriting the original object
 (this only matters in the <strong>__bytes</strong>-as-function case, since otherwise the
 object will already be in position).</p>

<p> Should an error happen along the way, <strong>mBytes</strong> will be <code>NULL</code> and an error
 message is pushed on the stack.</p>



<br/>
<br/>




</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
