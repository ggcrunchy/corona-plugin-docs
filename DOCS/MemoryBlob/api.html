<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>MemoryBlob</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>memoryblob</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>memoryblob</code></h1>
<p>Auxiliary library for creating memory blobs, for instance to recycle or share native resources.</p>
<p>


<p> Some concurrency primitives are provided, built upon <a href="https://github.com/efficient/libcuckoo">libcuckoo</a>.
 (At the moment, Corona uses libstdc++ on iOS, which makes libcuckoo support too difficult. A basic
 mutex / map combination is used instead, but alternatives are under investigation.)</p>

<p> To use the plugin, add the following in <code>build.settings</code>:</p>

<p> <pre><code class="language-lua">plugins = {
   ["plugin.MemoryBlob"] = { publisherId = "com.xibalbastudios" }
 }</code></pre></p>

<p> Sample code is available <a href="https://github.com/ggcrunchy/corona-plugin-docs/tree/master/MemoryBlob_sample">here</a>.</p>

<p> Once this plugin has been loaded, native plugins may create and manage blobs via the <a href="https://raw.githubusercontent.com/ggcrunchy/corona_enterprise_utils/master/utils/Blob.h">BlobXS API</a>.
 Until then, any calls to the API will be suitable no-ops. (Documentation is lacking at the moment!)</p>

<p> Blobs implement the <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/ByteReader/policy.html">ByteReader protocol</a>.</p>

<p> The <strong>Bytes</strong> type&mdash;specified in a few of the blob methods&mdash;may be any object that implements <strong>ByteReader</strong>,
 including strings.</p>

<p> Functions and sections that begin with (<strong>WIP</strong>) describe work in progress. These features are not considered stable,
 but give a reasonable idea of what to expect.</p>

<hr/>

<p> <strong>From <a href="https://github.com/efficient/libcuckoo#licence">libcuckoo's license</a>:</strong></p>

<p> Copyright (C) 2013, Carnegie Mellon University and Intel Corporation</p>

<p> Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at</p>

<p>   <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>

<p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 the specific language governing permissions and limitations under the License.</p>

<hr/>

<p> <strong>From the <a href="https://raw.githubusercontent.com/efficient/libcuckoo/master/cityhash-1.1.1/COPYING">license of CityHash</a>
 (used by libcuckoo)</strong>:</p>

<p> Copyright (c) 2011 Google, Inc.</p>

<p> Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:</p>

<p> The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.</p>

<p> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.</p>

<hr/>
</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#ExistsInStorage">ExistsInStorage (id)</a></td>
	<td class="summary">(<strong>WIP</strong>) Check whether an entry exists in storage.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#GetBlobDispatcher">GetBlobDispatcher ()</a></td>
	<td class="summary">Get the dispatcher used by blob-related events, in order to add / remove listeners.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#IsBlob">IsBlob (object, type)</a></td>
	<td class="summary">Indicates whether an object is a <strong>MemoryBlob</strong>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#New">New (opts)</a></td>
	<td class="summary">Create a new memory blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Append">MemoryBlob:Append (bytes)</a></td>
	<td class="summary">Add bytes to the end of the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Clone">MemoryBlob:Clone ()</a></td>
	<td class="summary">Create a clone of the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:GetBytes">MemoryBlob:GetBytes ([i1=1[, i2=#self]])</a></td>
	<td class="summary">Dump the blob's contents as a string of bytes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:GetProperties">MemoryBlob:GetProperties (out)</a></td>
	<td class="summary">
<p>Populate a table with the following blob properties:</p>

<ul>
    <li><strong>alignment</strong>: As per <a href="api.html#New">New</a>, an integer &ge; 0, with 0 meaning default alignment.</li>
</ul>
</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Insert">MemoryBlob:Insert (pos, bytes)</a></td>
	<td class="summary">Insert bytes into the blob, starting at position <em>pos</em>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:IsLocked">MemoryBlob:IsLocked ()</a></td>
	<td class="summary">Indicates whether writes to this blob are restricted (via the native API).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:__len">MemoryBlob:__len ()</a></td>
	<td class="summary">Metamethod.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Remove">MemoryBlob:Remove ([i1=1[, i2=#self]])</a></td>
	<td class="summary">Remove a range of bytes from the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Submit">MemoryBlob:Submit ()</a></td>
	<td class="summary">(<strong>WIP</strong>) Submit this blob's contents to storage.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Sync">MemoryBlob:Sync (id)</a></td>
	<td class="summary">(<strong>WIP</strong>) Synchronize this blob with an entry in storage, which then ceases to exist.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Write">MemoryBlob:Write (pos, bytes)</a></td>
	<td class="summary">Write bytes to the blob, starting at position <em>pos</em>, overwriting the blob's contents.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "ExistsInStorage"></a>
    <strong>ExistsInStorage (id)</strong>
    </dt>
    <dd>
    (<strong>WIP</strong>) Check whether an entry exists in storage.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Stored entry's lookup ID, cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        The entry exists?
    </ol>




</dd>
    <dt>
    <a name = "GetBlobDispatcher"></a>
    <strong>GetBlobDispatcher ()</strong>
    </dt>
    <dd>
    Get the dispatcher used by blob-related events, in order to add / remove listeners. </p>

<p> Calling this outside <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/luaproc/api.html#is_main_state">Corona's main thread</a>
 results in an error.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">EventDispatcher</span></span>
        Dispatcher.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>
    </ul>


</dd>
    <dt>
    <a name = "IsBlob"></a>
    <strong>IsBlob (object, type)</strong>
    </dt>
    <dd>
    Indicates whether an object is a <strong>MemoryBlob</strong>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">object</span>
         Object to check.
        </li>
        <li><span class="parameter">type</span>
            <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         If present, refine the query to only consider blobs of a given type, cf. <a href="api.html#New">New</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is <em>object</em> a blob?
    </ol>




</dd>
    <dt>
    <a name = "New"></a>
    <strong>New (opts)</strong>
    </dt>
    <dd>
    Create a new memory blob. </p>

<p> No assumptions should be made about the original contents; whatever the allocator provides is left intact.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">opts</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a>, <span class="type">uint</span> or <span class="type">nil</span></span>
         Blob creation options.</p>

<p> When <em>opts</em> is a table, it may contain the following options:</p>

<ul>
    <li><strong>alignment</strong>: If specified, the memory alignment, which must be a multiple of 2, &ge; 4. The
    blob's memory will start at an address that is a multiple of this value, which is useful and / or
    needed e.g. for SIMD operations. By default, blobs use the Lua allocator's alignment.
    <br/><br/>
    Currently, the upper limit is 1024, one level beyond <a href="https://en.wikipedia.org/wiki/Advanced_Vector_Extensions#Advanced_Vector_Extensions_2">AVX2</a> support.</li>
    <li><strong>resizable</strong>: If true, the blob can be resized. Off by default.</li>
    <li><strong>size</strong>: Blob size in bytes, &ge; 0. For resizable blobs, this is the blob's initial size;
    otherwise, it specifies the fixed size. If absent, 0.</li>
    <li><strong>type</strong>: A string that will be used to name the blob userdata's metatable; if absent, uses a default.
    <br/><br/>
    Blobs themselves make no further use of this value; rather it is exposed as a convenience, e.g. so
    plugin authors can identify their own blobs via <a href="api.html#IsBlob">IsBlob</a>.</li>
</ul>

<p> If <em>opts</em> is an integer, it specifies the fixed size (&ge; 0) of the blob to create.</p>

<p> For any other value of <em>opts</em>, a resizable blob will be created.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">MemoryBlob</span></span>
        The new blob.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Append"></a>
    <strong>MemoryBlob:Append (bytes)</strong>
    </dt>
    <dd>
    Add bytes to the end of the blob. </p>

<p> This is a no-op for fixed-size and locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually written.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Clone"></a>
    <strong>MemoryBlob:Clone ()</strong>
    </dt>
    <dd>
    Create a clone of the blob. </p>

<p> The clone inherits the alignment, resizability, size, and type of the original blob.</p>

<p> Initially, the clone will contain a copy of the parent's current contents. The two blobs are independent,
 however; changes to one's contents are not reflected in the other.</p>

<p> Clones begin unlocked.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">MemoryBlob</span></span>
        Cloned blob.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:GetBytes"></a>
    <strong>MemoryBlob:GetBytes ([i1=1[, i2=#self]])</strong>
    </dt>
    <dd>
    Dump the blob's contents as a string of bytes. </p>

<p> If either index refers to a position outside the blob, or <em>i1</em> &gt; <em>i2</em> (after normalizing any
 negative indices), an empty string is returned.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">i1</span>
            <span class="types"><span class="type">uint</span></span>
         Index of first byte. If negative, the index counts down from the end of the blob, much like
 certain Lua <a href="https://docs.coronalabs.com/api/library/string/sub.html">string functions</a>.
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">i2</span>
            <span class="types"><span class="type">uint</span></span>
         Index of last byte. Again, indices may be negative.
         (<em>default</em> #self)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        Copy of current blob contents.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:GetProperties"></a>
    <strong>MemoryBlob:GetProperties (out)</strong>
    </dt>
    <dd>

<p>Populate a table with the following blob properties:</p>

<ul>
    <li><strong>alignment</strong>: As per <a href="api.html#New">New</a>, an integer &ge; 0, with 0 meaning default alignment. </li>
    <li><strong>resizable</strong>: As per <a href="api.html#New">New</a>, a boolean indicating resizability.</li>
</ul>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">out</span>
            <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         Table to populate and return. If absent, a fresh table is created.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        Properties table.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Insert"></a>
    <strong>MemoryBlob:Insert (pos, bytes)</strong>
    </dt>
    <dd>
    Insert bytes into the blob, starting at position <em>pos</em>. </p>

<p> The current contents from <em>pos</em> onward are moved ahead #<em>bytes</em> positions to make room. In the case of
 fixed-size blobs, any bytes moved beyond the end of the blob are thrown away.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pos</span>
            <span class="types"><span class="type">int</span></span>
         Insert position, between 1 and #<em>self</em>, inclusive. A negative index may also be provided,
 cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a> for details.</p>

<p> Resizable blobs may also use position #<em>self</em> + 1, with behavior like <code>self:Append(bytes)</code>.</p>

<p> No bytes are inserted when the position lies outside the legal range.
        </li>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to insert.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually inserted.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:Append">MemoryBlob:Append</a></li>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:IsLocked"></a>
    <strong>MemoryBlob:IsLocked ()</strong>
    </dt>
    <dd>
    Indicates whether writes to this blob are restricted (via the native API). </p>

<p> Certain MemoryBlob methods will early-out when given a locked blob, cf. various summaries.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        The blob is locked?
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:__len"></a>
    <strong>MemoryBlob:__len ()</strong>
    </dt>
    <dd>
    Metamethod.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Current size of blob, in bytes.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Remove"></a>
    <strong>MemoryBlob:Remove ([i1=1[, i2=#self]])</strong>
    </dt>
    <dd>
    Remove a range of bytes from the blob. </p>

<p> Any bytes beyond <em>i2</em> will be moved down to fill the vacated positions.</p>

<p> Naturally, resizable blobs will shrink. Since fixed-size blobs cannot do this, there will be <em>i2</em> -
 <em>i1</em> + 1 "extra" bytes at the end, after elements move down; these will be left as-is.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">i1</span>
            <span class="types"><span class="type">int</span></span>
         Index of first byte to remove, cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a>.
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">i2</span>
            <span class="types"><span class="type">int</span></span>
         Index of last byte to remove, ditto.
         (<em>default</em> #self)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually removed.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Submit"></a>
    <strong>MemoryBlob:Submit ()</strong>
    </dt>
    <dd>
    (<strong>WIP</strong>) Submit this blob's contents to storage.  This is a mechanism geared toward
 sharing memory among <a href="https://ggcrunchy.github.io/corona-pluin-docs/DOCS/luaproc/api.html">Lua processes</a>,
 which can even be done without copying when certain conditions are met (cf. <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a> for details,
 as well as the comments about resizable blobs that follow).</p>

<p> Essentially, an empty resizable blob with the same alignment is first created in storage.</p>

<p> If the original blob is resizable, its contents are swapped directly into the stored entry.</p>

<p> Fixed-size blobs cannot do this, so something like <code>entry:Append(fixed_blob)</code> is done instead.</p>

<p> To keep memory under control, any blobs in storage left unsynchronized will be evicted after a few frames have
 gone by (on average, 5). Listeners for <strong>"stale_entry"</strong> will be sent a message each time this happens (cf.
 <a href="api.html#GetBlobDispatcher">GetBlobDispatcher</a>), with an <strong>id</strong> field containing the former entry's ID.</p>

<p> This is a no-op for locked, resizable blobs.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a> or <span class="type">nil</span></span>
        On success, an ID for later use by <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a>. Otherwise, <strong>nil</strong>.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#ExistsInStorage">ExistsInStorage</a></li>
         <li><a href="api.html#MemoryBlob:Append">MemoryBlob:Append</a></li>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Sync"></a>
    <strong>MemoryBlob:Sync (id)</strong>
    </dt>
    <dd>
    (<strong>WIP</strong>) Synchronize this blob with an entry in storage, which then ceases to exist. </p>

<p> For fixed-size blobs, this is essentially <code>self:Write(1, bytes)</code>, with <em>bytes</em> being the entry's contents.</p>

<p> With resizable blobs, the same is true, but the blob's length is also trimmed to #<em>bytes</em>, if necessary.
 When the blob and stored entry have a common alignment (cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>), the blob simply assumes
 ownership of the latter's contents, forgoing a potentially expensive copy.</p>

<p> This operation is designed for safe communication between <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/luaproc/api.html">Lua processes</a>.</p>

<p> This is a no-op for locked blobs, or if <em>id</em> does not refer to a valid entry.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">id</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Stored entry's lookup ID, cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Synchronization succeeded?
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#ExistsInStorage">ExistsInStorage</a></li>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:Write">MemoryBlob:Write</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Write"></a>
    <strong>MemoryBlob:Write (pos, bytes)</strong>
    </dt>
    <dd>
    Write bytes to the blob, starting at position <em>pos</em>, overwriting the blob's contents. </p>

<p> Resizable blobs will grow to accommodate these bytes, if necessary, whereas writes to fixed-size
 blobs will stop if they reach the end.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pos</span>
            <span class="types"><span class="type">int</span></span>
         Write position, between 1 and #<em>self</em>, inclusive.  A negative index may also be provided,
 cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a> for details.</p>

<p> Resizable blobs may also use position #<em>self</em> + 1, with behavior like <code>self:Append(bytes)</code>.</p>

<p> No bytes are written when the position lies outside the legal range.
        </li>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually written.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:Append">MemoryBlob:Append</a></li>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
