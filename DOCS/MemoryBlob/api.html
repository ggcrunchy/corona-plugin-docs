<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>MemoryBlob</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>memoryblob</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>memoryblob</code></h1>
<p>Auxiliary library for creating memory blobs, for instance to recycle or share native resources.</p>
<p>


<p> Some concurrency primitives are provided, built upon <a href="https://github.com/efficient/libcuckoo">libcuckoo</a>.</p>

<p> To use the plugin, add the following in <code>build.settings</code>:</p>

<p> <pre><code class="language-lua">plugins = {
   ["plugin.MemoryBlob"] = { publisherId = "com.xibalbastudios" }
 }</code></pre></p>

<p> Sample code is available <a href="https://github.com/ggcrunchy/corona-plugin-docs/tree/master/MemoryBlob_sample">here</a>.</p>

<p> Once this plugin has been loaded, native plugins may create and manage blobs via the <a href="https://raw.githubusercontent.com/ggcrunchy/corona_enterprise_utils/master/utils/Blob.h">BlobXS API</a>.</p>

<p> Blobs implement the <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/ByteReader/policy.html">ByteReader protocol</a>.</p>

<p> The <strong>Bytes</strong> type&mdash;specified in a few of the blob methods&mdash;may be any object that implements <strong>ByteReader</strong>,
 including strings.</p>

<hr/>

<p> <strong>From <a href="https://github.com/efficient/libcuckoo#licence">libcuckoo's license</a>:</strong></p>

<p> Copyright (C) 2013, Carnegie Mellon University and Intel Corporation</p>

<p> Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance
 with the License. You may obtain a copy of the License at</p>

<p>   <a href="http://www.apache.org/licenses/LICENSE-2.0">Apache License 2.0</a></p>

<p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed
 on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
 the specific language governing permissions and limitations under the License.</p>

<hr/>

<p> <strong>From the <a href="https://raw.githubusercontent.com/efficient/libcuckoo/master/cityhash-1.1.1/COPYING">license of CityHash</a>
 (used by libcuckoo)</strong>:</p>

<p> Copyright (c) 2011 Google, Inc.</p>

<p> Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:</p>

<p> The above copyright notice and this permission notice shall be included in
 all copies or substantial portions of the Software.</p>

<p> THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 THE SOFTWARE.</p>

<hr/>
</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#ExistsInBlobStorage">ExistsInBlobStorage (hash)</a></td>
	<td class="summary">Check whether an entry exists in blob storage.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#GetBlobDispatcher">GetBlobDispatcher ()</a></td>
	<td class="summary">Gets a dispatcher used by blob-related events, in order to add / remove listeners.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#InitializeBlobStorage">InitializeBlobStorage ()</a></td>
	<td class="summary">Initializes blob storage for <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a> and <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#IsBlob">IsBlob (object[, type])</a></td>
	<td class="summary">Indicates whether an object (which need not originate from this plugin) is a <strong>MemoryBlob</strong>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#New">New (opts)</a></td>
	<td class="summary">Creates a new memory blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Append">MemoryBlob:Append (bytes)</a></td>
	<td class="summary">Adds bytes to the end of the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Clone">MemoryBlob:Clone ()</a></td>
	<td class="summary">Creates a clone of the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:GetBytes">MemoryBlob:GetBytes ([i1=1[, i2=#self]])</a></td>
	<td class="summary">Dumps the blob's contents to a string of bytes.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:GetProperties">MemoryBlob:GetProperties ([out])</a></td>
	<td class="summary">
<p>Populates a table with the following blob properties:</p>

<ul>
    <li><strong>alignment</strong>: As per <a href="api.html#New">New</a>, an integer &ge; 0, where 0 indicates default alignment.</li>
</ul>
</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Insert">MemoryBlob:Insert (pos, bytes)</a></td>
	<td class="summary">Inserts bytes into the blob, starting at position <em>pos</em>.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:IsLocked">MemoryBlob:IsLocked ()</a></td>
	<td class="summary">Indicates whether writes to this blob are restricted (via the native API).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:__len">MemoryBlob:__len ()</a></td>
	<td class="summary">Metamethod.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Remove">MemoryBlob:Remove ([i1=1[, i2=#self]])</a></td>
	<td class="summary">Removes a range of bytes from the blob.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Submit">MemoryBlob:Submit ()</a></td>
	<td class="summary">Submit this blob's contents to blob storage.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Sync">MemoryBlob:Sync (hash)</a></td>
	<td class="summary">Synchronizes this blob with an entry in blob storage, which then ceases to exist.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#MemoryBlob:Write">MemoryBlob:Write (pos, bytes)</a></td>
	<td class="summary">Writes bytes to the blob, starting at position <em>pos</em>, overwriting the blob's contents.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "ExistsInBlobStorage"></a>
    <strong>ExistsInBlobStorage (hash)</strong>
    </dt>
    <dd>
    Check whether an entry exists in blob storage.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">hash</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Stored entry's lookup hash, cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        The entry exists?
    </ol>




</dd>
    <dt>
    <a name = "GetBlobDispatcher"></a>
    <strong>GetBlobDispatcher ()</strong>
    </dt>
    <dd>
    Gets a dispatcher used by blob-related events, in order to add / remove listeners. </p>

<p> Calling this outside <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/luaproc/api.html#is_main_state">Corona's main thread</a>
 results in an error.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">EventDispatcher</span></span>
        Dispatcher.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>
    </ul>


</dd>
    <dt>
    <a name = "InitializeBlobStorage"></a>
    <strong>InitializeBlobStorage ()</strong>
    </dt>
    <dd>
    Initializes blob storage for <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a> and <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a>. </p>

<p> Calling this outside <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/luaproc/api.html#is_main_state">Corona's main thread</a>
 results in an error.</p>

<p> Subsequent calls are no-ops.






</dd>
    <dt>
    <a name = "IsBlob"></a>
    <strong>IsBlob (object[, type])</strong>
    </dt>
    <dd>
    Indicates whether an object (which need not originate from this plugin) is a <strong>MemoryBlob</strong>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">object</span>
         Object to check.
        </li>
        <li><span class="parameter">type</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         If present, refine the query to only consider blobs of a given type, cf. <a href="api.html#New">New</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is <em>object</em> a blob?
    </ol>




</dd>
    <dt>
    <a name = "New"></a>
    <strong>New (opts)</strong>
    </dt>
    <dd>
    Creates a new memory blob.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">opts</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a>, <span class="type">uint</span> or <span class="type">nil</span></span>
         Blob creation options.</p>

<p> When <em>opts</em> is a table, it may contain the following options:</p>

<ul>
    <li><strong>alignment</strong>: If specified, the memory alignment, which must be a multiple of 2, &ge; 4. The
    blob's memory will start at an address that is a multiple of this value, which is useful and / or
    needed e.g. for SIMD operations. By default, blobs use the Lua allocator's alignment.</li>
    <li><strong>resizable</strong>: If true, the blob can be resized (via the native API). Off by default.</li>
    <li><strong>size</strong>: Blob size, in bytes. For resizable blobs, this is the blob's initial size
    (&ge; 0; if absent, 0); otherwise, it specifies the fixed size &gt; 0 and is mandatory.</li>
    <li><strong>type</strong>: A string that will be used as the blob userdata's metatable name; if absent, a default
    is used. Blobs themselves make no further use of this value; rather it is exposed as a convenience,
    e.g. so plugin authors can identify their own blobs via <a href="api.html#IsBlob">IsBlob</a>.</li>
</ul>

<p> If <em>opts</em> is an integer (&gt; 0), it specifies the fixed size of the blob to create.</p>

<p> For any other value of <em>opts</em>, a resizable blob will be created.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">MemoryBlob</span></span>
        The new blob.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Append"></a>
    <strong>MemoryBlob:Append (bytes)</strong>
    </dt>
    <dd>
    Adds bytes to the end of the blob. </p>

<p> This is a no-op for fixed-size and locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually written.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Clone"></a>
    <strong>MemoryBlob:Clone ()</strong>
    </dt>
    <dd>
    Creates a clone of the blob. </p>

<p> The clone inherits the alignment, resizability, size, and type of the original blob.</p>

<p> Initially, the clone will contain a copy of the parent's current bytes. The two blobs are independent,
 however; changes to one's contents are not reflected in the other.</p>

<p> Clones begin unlocked.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">MemoryBlob</span></span>
        Cloned blob.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:GetBytes"></a>
    <strong>MemoryBlob:GetBytes ([i1=1[, i2=#self]])</strong>
    </dt>
    <dd>
    Dumps the blob's contents to a string of bytes. </p>

<p> If either index refers to a position outside the blob, or <em>i1</em> &gt; <em>i2</em> (after normalizing any
 negative indices), an empty string is returned.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">i1</span>
            <span class="types"><span class="type">uint</span></span>
         Index of first byte. If negative, the index counts down from the end of the blob, much like
 certain Lua <a href="https://docs.coronalabs.com/api/library/string/sub.html">string functions</a>.
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">i2</span>
            <span class="types"><span class="type">uint</span></span>
         Index of last byte. Again, indices may be negative.
         (<em>default</em> #self)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        Copy of current blob bytes.
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:GetProperties"></a>
    <strong>MemoryBlob:GetProperties ([out])</strong>
    </dt>
    <dd>

<p>Populates a table with the following blob properties:</p>

<ul>
    <li><strong>alignment</strong>: As per <a href="api.html#New">New</a>, an integer &ge; 0, where 0 indicates default alignment. </li>
    <li><strong>resizable</strong>: As per <a href="api.html#New">New</a>, a boolean indicating resizability.</li>
</ul>


    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">out</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
         If provided, this table is populated and returned; otherwise, a fresh table
 is created.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.5">table</a></span>
        Properties table.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Insert"></a>
    <strong>MemoryBlob:Insert (pos, bytes)</strong>
    </dt>
    <dd>
    Inserts bytes into the blob, starting at position <em>pos</em>. </p>

<p> The current contents from <em>pos</em> onward are moved ahead #<em>bytes</em> positions to make room. In the case of
 fixed-size blobs, any bytes moved beyond the end of the blob are thrown away.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pos</span>
            <span class="types"><span class="type">int</span></span>
         Insert position, &isin; [1, #<em>self</em>]. (In the case of resizable blobs, #<em>self</em> + 1 is
 also valid; the call is then effectively <a href="api.html#MemoryBlob:Append">MemoryBlob:Append</a>.) A negative index may also be
 provided, cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a> for details.</p>

<p> No bytes are inserted when the position lies outside the legal range.
        </li>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to insert.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually inserted.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:IsLocked"></a>
    <strong>MemoryBlob:IsLocked ()</strong>
    </dt>
    <dd>
    Indicates whether writes to this blob are restricted (via the native API). </p>

<p> As described in various summaries, certain MemoryBlob methods will do nothing or fail, when
 given a locked blob.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        The blob is locked?
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:__len"></a>
    <strong>MemoryBlob:__len ()</strong>
    </dt>
    <dd>
    Metamethod.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Current size of blob, in bytes.
    </ol>




</dd>
    <dt>
    <a name = "MemoryBlob:Remove"></a>
    <strong>MemoryBlob:Remove ([i1=1[, i2=#self]])</strong>
    </dt>
    <dd>
    Removes a range of bytes from the blob. </p>

<p> Any bytes beyond <em>i2</em> will be moved down to fill the vacated positions.</p>

<p> Resizable blobs will be shrunk to match the new size. Since fixed-size blobs cannot do this,
 there will be some "extra" bytes after bytes are moved down; these will be left as-is.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">i1</span>
            <span class="types"><span class="type">int</span></span>
         Index of first byte to remove, cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a>.
         (<em>default</em> 1)
        </li>
        <li><span class="parameter">i2</span>
            <span class="types"><span class="type">int</span></span>
         Index of last byte to remove, ditto.
         (<em>default</em> #self)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually removed.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Submit"></a>
    <strong>MemoryBlob:Submit ()</strong>
    </dt>
    <dd>
    Submit this blob's contents to blob storage.  This is a mechanism geared toward
 memory sharing among <a href="https://ggcrunchy.github.io/corona-pluin-docs/DOCS/luaproc/api.html">Lua processes</a>,
 which can even be done without copying when certain conditions are met (cf. <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a> for details,
 as well as the comment about resizable blobs that follows).</p>

<p> Essentially, a resizable blob is first created in blob storage, with the same alignment as this blob.</p>

<p> If this blob is resizable, its contents are given to the stored entry directly. It will then be empty.</p>

<p> Fixed-size blobs must instead copy their contents into the entry. The original data is left intact.</p>

<p> The entry will persist until synchronization or some number of frames (&gt; 1) have elapsed. The latter is a check
 against runaway growth, since stale entries would accumulate over time.</p>

<p> Listeners for <strong>"stale_entry"</strong> will be sent a message when a long-lived entry is evicted from blob
 storage. The message's <strong>hash</strong> field will contain the former entry's hash.</p>

<p> This is a no-op for locked, resizable blobs, or if <a href="api.html#InitializeBlobStorage">InitializeBlobStorage</a> has not been called.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a> or <span class="type">nil</span></span>
        On success, a hash for later use by <a href="api.html#MemoryBlob:Sync">MemoryBlob:Sync</a>. Otherwise, <strong>nil</strong>.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#ExistsInBlobStorage">ExistsInBlobStorage</a></li>
         <li><a href="api.html#GetBlobDispatcher">GetBlobDispatcher</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Sync"></a>
    <strong>MemoryBlob:Sync (hash)</strong>
    </dt>
    <dd>
    Synchronizes this blob with an entry in blob storage, which then ceases to exist. </p>

<p> For fixed-size blobs, this is essentially <code>self:Write(1, bytes)</code>, with <em>bytes</em> being the entry's contents.</p>

<p> With resizable blobs, the same is true, but the blob's length is also trimmed to #<em>bytes</em>, if necessary.
 When the blob and stored entry have a common alignment (cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>), the blob simply assumes
 ownership of the latter's contents, forgoing a potentially expensive copy.</p>

<p> This operation is designed for safe communication between <a href="https://ggcrunchy.github.io/corona-plugin-docs/DOCS/luaproc/api.html">Lua processes</a>.</p>

<p> This is a no-op for locked blobs. The same is true if <em>hash</em> does not refer to a valid entry, or if
 <a href="api.html#InitializeBlobStorage">InitializeBlobStorage</a> has not been called.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">hash</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Stored entry's lookup hash, cf. <a href="api.html#MemoryBlob:Submit">MemoryBlob:Submit</a>.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Synchronization succeeded?
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#ExistsInBlobStorage">ExistsInBlobStorage</a></li>
         <li><a href="api.html#MemoryBlob:Write">MemoryBlob:Write</a></li>
    </ul>


</dd>
    <dt>
    <a name = "MemoryBlob:Write"></a>
    <strong>MemoryBlob:Write (pos, bytes)</strong>
    </dt>
    <dd>
    Writes bytes to the blob, starting at position <em>pos</em>, overwriting the blob's contents. </p>

<p> Resizable blobs will grow to accommodate these bytes, if necessary, whereas writes to fixed-size
 blobs will stop if they reach the end.</p>

<p> This is a no-op for locked blobs.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">pos</span>
            <span class="types"><span class="type">int</span></span>
         Write position, between 1 and #<em>self</em>, inclusive. (In the case of resizable blobs, #<em>self</em> + 1 is
 also valid; the call is then effectively <a href="api.html#MemoryBlob:Append">MemoryBlob:Append</a>.) A negative index may also be
 provided, cf. <a href="api.html#MemoryBlob:GetBytes">MemoryBlob:GetBytes</a> for details.</p>

<p> No bytes are written when the position lies outside the legal range.
        </li>
        <li><span class="parameter">bytes</span>
            <span class="types"><span class="type">Bytes</span></span>
         Bytes to write.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">uint</span></span>
        Number of bytes actually written.
    </ol>


    <h3>See also:</h3>
    <ul>
         <li><a href="api.html#MemoryBlob:IsLocked">MemoryBlob:IsLocked</a></li>
         <li><a href="api.html#MemoryBlob:__len">MemoryBlob:__len</a></li>
    </ul>


</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
