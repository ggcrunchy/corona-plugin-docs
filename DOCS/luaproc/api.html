<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Documentation</title>
    <link rel="stylesheet" href="ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>luaproc</h1>


<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>luaproc</strong></li>
</ul>

</div>

<div id="content">

<h1>Module <code>luaproc</code></h1>
<p>Corona binding for <a href="https://github.com/askyrme/luaproc">luaproc</a>, a concurrent programming library for Lua.</p>
<p> To use the plugin, add the following in <code>build.settings</code>:</p>

<p> <pre><code class="language-lua">plugins = { <br/>
   ["plugin.luaproc"] = { publisherId = "com.xibalbastudios" }
 }</code></pre></p>

<p> Sample code is available <a href="https://github.com/ggcrunchy/corona-plugin-docs/blob/master/luaproc.lua">here</a>.</p>

<p> <strong>From the project page:</strong></p>

<p> <em>luaproc</em> is a Lua extension library for concurrent programming. This text provides some background information
 and also serves as a reference manual for the library. The library is available under the same <a href="http://www.lua.org/copyright.html">terms and conditions</a>
 as the Lua language, the MIT license. The idea is that if you can use Lua in a project, you should also be able
 to use <em>luaproc</em>.</p>

<p> Lua natively supports cooperative multithreading by means of coroutines. However, coroutines in Lua cannot be
 executed in parallel. <em>luaproc</em> overcomes that restriction by building on the proposal and sample implementation
 presented in <a href="http://www.inf.puc-rio.br/~roberto/pil2">Programming in Lua</a> (chapter 30). It uses coroutines and
 multiple independent states in Lua to implement Lua processes, which are user threads comprised of Lua code that
 have no shared data. Lua processes are executed by workers, which are system threads implemented with POSIX threads
 (pthreads), and thus can run in parallel.</p>

<p> Communication between Lua processes relies exclusively on message passing. Each message can carry a tuple of atomic
 Lua values (strings, numbers, booleans and <strong>nil</strong>). More complex types must be encoded somehow &mdash; for instance
 by using strings of Lua code that when executed return such a type. Message addressing is based on communication
 channels, which are decoupled from Lua processes and must be explicitly created.</p>

<p> Sending a message is always a synchronous operation, i.e., the send operation only returns after a message has been
 received by another Lua process or if an error occurs (such as trying to send a message to a non-existent channel).
 Receiving a message, on the other hand, can be a synchronous or asynchronous operation. In synchronous mode, a call
 to the receive operation only returns after a message has been received or if an error occurs. In asynchronous mode,
 a call to the receive operation returns immediately and indicates if a message was received or not.</p>

<p> If a Lua process tries to send a message to a channel where there are no Lua processes waiting to receive a message,
 its execution is suspended until a matching receive occurs or the channel is destroyed. The same happens if a Lua
 process tries to synchronously receive a message from a channel where there are no Lua processes waiting to send a
 message.</p>

<p> <em>luaproc</em> also offers an optional facility to recycle Lua processes. Recycling consists of reusing states from
 finished Lua processes, instead of destroying them. When recycling is enabled, a new Lua process can be created by
 loading its code in a previously used state from a finished Lua process, instead of creating a new state.</p>

<p> <strong>References</strong></p>

<p> A paper about <em>luaproc</em> &mdash; Exploring Lua for Concurrent Programming &mdash; was published in the Journal of
 Universal Computer Science and is available <a href="http://www.jucs.org/jucs_14_21/exploring_lua_for_concurrent">here</a> and
 <a href="http://www.inf.puc-rio.br/~roberto/docs/ry08-05.pdf">here</a>. Some information in the paper is already outdated, but
 it still provides a good overview of the library and some of its design choices.</p>

<p> A tech report about concurrency in Lua, which uses <em>luaproc</em> as part of a case study, is also available
 <a href="ftp://ftp.inf.puc-rio.br/pub/docs/techreports/11_13_skyrme.pdf">here</a>.</p>

<p> Finally, a paper about an experiment to port <em>luaproc</em> to use Transactional Memory instead of the standard POSIX Threads
 synchronization constructs, published as a part of the 8th ACM SIGPLAN Workshop on Transactional Computing, can be found
 <a href="http://transact2013.cse.lehigh.edu/skyrme.pdf">here</a>.</p>

<p> Copyright Â© 2008-2015 Alexandre Skyrme, Noemi Rodriguez, Roberto Ierusalimschy.
 All rights reserved.</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#newproc">newproc (lua_code)</a></td>
	<td class="summary">Creates a new Lua process to run the specified string of Lua code.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#newproc">newproc (f)</a></td>
	<td class="summary">Variant of <strong>newproc</strong> that accepts a function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setnumworkers">setnumworkers (number_of_workers)</a></td>
	<td class="summary">Sets the number of active workers (pthreads) to n (default = 1, minimum = 1).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getnumworkers">getnumworkers ()</a></td>
	<td class="summary">Returns the number of active workers (pthreads).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait ()</a></td>
	<td class="summary">Waits until all Lua processes have finished, then continues program execution.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#recycle">recycle (maxrecycle)</a></td>
	<td class="summary">Sets the maximum number of Lua processes to recycle.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#send">send (channel_name, ...)</a></td>
	<td class="summary">Sends a message (tuple of boolean, <strong>nil</strong>, number or string values) to a channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#send_allow_from_main">send_allow_from_main ()</a></td>
	<td class="summary">Variant of <a href="api.html#send">send</a> that allows unmatched sends from Corona's thread.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#receive">receive (channel_name[, asynchronous=false])</a></td>
	<td class="summary">Receives a message (tuple of boolean, <strong>nil</strong>, number or string values) from a channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#receive_allow_from_main">receive_allow_from_main ()</a></td>
	<td class="summary">Variant of <a href="api.html#receive">receive</a> that allows unmatched receives from Corona's thread.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#newchannel">newchannel (channel_name)</a></td>
	<td class="summary">Creates a new channel identified by string name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delchannel">delchannel (channel_name)</a></td>
	<td class="summary">Destroys a channel identified by string name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#alert">alert (message, payload)</a></td>
	<td class="summary">Dispatch an alert event (in the main state), e.g.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#get_alert_dispatcher">get_alert_dispatcher ()</a></td>
	<td class="summary">Gets the dispatcher used by <a href="api.html#alert">alert</a>, in order to add / remove listeners.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#is_main_state">is_main_state ()</a></td>
	<td class="summary">Check whether the running process is in the main state.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#is_waiting">is_waiting ()</a></td>
	<td class="summary">Check whether <em>luaproc</em> is waiting for processes to finish, either after a call to <a href="api.html#wait">wait</a> or while closing.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#sleep">sleep (ms)</a></td>
	<td class="summary">Causes the current process to sleep.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wants_to_close">wants_to_close ()</a></td>
	<td class="summary">Indicates whether Lua wants to close, either from trying to exit the app or Corona simulator, or on account of relaunching the Corona simulator.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "newproc"></a>
    <strong>newproc (lua_code)</strong>
    </dt>
    <dd>
    Creates a new Lua process to run the specified string of Lua code.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error
 message if failed. The only libraries loaded in new Lua processes are <em>luaproc</em> itself (available as the global <strong>luaproc</strong>) and
 the standard Lua base and <a href="https://docs.coronalabs.com/api/library/package/index.html">package</a> libraries.</p>

<p> The remaining standard Lua libraries (<strong>io</strong>, <strong>os</strong>, <strong>table</strong>, <strong>string</strong>, <strong>math</strong>, <strong>debug</strong>, and <strong>coroutine</strong>) are
 pre-registered and can be loaded with a call to the standard Lua function
 <a href="https://docs.coronalabs.com/api/library/package/require.html">require</a>. (The sample suggests some steps for bringing in other
 modules.)</p>

<p> In addition, <strong>system</strong> can be <strong>require()</strong>'d in a similar way. This contains approximations of the following Corona built-ins,
 under the same names: <strong>CachesDirectory</strong>, <strong>DocumentsDirectory</strong>, <strong>ResourceDirectory</strong>, <strong>TemporaryDirectory</strong>, <strong>getTimer()</strong>,
 and <strong>pathForFile()</strong>.</p>

<p> Note that processes are unique Lua states, so Lua modules loaded in multiple processes, or in one process as well as Corona's own
 thread, will have different contents. Special care must be taken in the case of dynamically loaded libraries, since these may keep
 some of their state outside Lua.</p>

<p> Thus, libraries meant to allow use in multiple processes should provide explicit guarantees and / or guidelines. This might come
 in various forms. For instance, a library that keeps no state at all is fine. Other possibilities include keeping state in
 thread-specific data, or in individually instantiated "world" objects.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lua_code</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         String of Lua code.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <strong>true</strong>, indicating success.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "newproc"></a>
    <strong>newproc (f)</strong>
    </dt>
    <dd>
    Variant of <strong>newproc</strong> that accepts a function. </p>

<p> Boolean, <strong>nil</strong>, number, and string upvalues will be copied over to this function (at this point, they are their own values).
 Upvalues of any other type will result in an error. Be aware that this will make innocuous snippets such as</p>
<pre><code>local luaproc = require("plugin.luaproc")
luaproc.newchannel("channel")
luaproc.newproc(function()
  luaproc.send("channel", "ERROR!") -- error: tries to capture luaproc as upvalue
end)
</code></pre>
<p> error out.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f</span>
            <span class="types"><span class="type">function</span></span>
         Function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <strong>true</strong>, indicating success.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "setnumworkers"></a>
    <strong>setnumworkers (number_of_workers)</strong>
    </dt>
    <dd>
    Sets the number of active workers (pthreads) to n (default = 1, minimum = 1). </p>

<p> Creates and destroys workers as needed, depending on the current number of active workers.</p>

<p> No return, raises error if worker could not be created.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">number_of_workers</span>
            <span class="types"><span class="type">int</span></span>
         Number of active workers.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "getnumworkers"></a>
    <strong>getnumworkers ()</strong>
    </dt>
    <dd>
    Returns the number of active workers (pthreads).


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        Number of active workers.
    </ol>




</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait ()</strong>
    </dt>
    <dd>
    Waits until all Lua processes have finished, then continues program execution. </p>

<p> It only makes sense to call this function from the main Lua script, i.e. from Corona's thread. Moreover, this function is
 implicitly called when the main Lua script finishes executing, e.g. on a simulator reset or when the app is about to exit.






</dd>
    <dt>
    <a name = "recycle"></a>
    <strong>recycle (maxrecycle)</strong>
    </dt>
    <dd>
    Sets the maximum number of Lua processes to recycle.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.
 The default number is zero, i.e., no Lua processes are recycled.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxrecycle</span>
            <span class="types"><span class="type">int</span></span>
         Maximum number of processes.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <strong>true</strong>, indicating success.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "send"></a>
    <strong>send (channel_name, ...)</strong>
    </dt>
    <dd>
    Sends a message (tuple of boolean, <strong>nil</strong>, number or string values) to a channel.  Returns <strong>true</strong> if successful or <strong>nil</strong> and
 an error message if failed. Suspends execution of the calling Lua process if there is no matching receive.</p>

<p> Calling this from Corona's thread results in an error if the channel is not already waiting for the results. This is usually desired,
 as Corona would be likely to block; <a href="api.html#send_allow_from_main">send_allow_from_main</a> is provided in case the more dangerous behavior is necessary.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
        <li><span class="parameter">...</span>
         Values to send, of the above-mentioned types.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <strong>true</strong>, indicating success.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "send_allow_from_main"></a>
    <strong>send_allow_from_main ()</strong>
    </dt>
    <dd>
    Variant of <a href="api.html#send">send</a> that allows unmatched sends from Corona's thread.






</dd>
    <dt>
    <a name = "receive"></a>
    <strong>receive (channel_name[, asynchronous=false])</strong>
    </dt>
    <dd>
    Receives a message (tuple of boolean, <strong>nil</strong>, number or string values) from a channel.  Returns received values if successful or
 <strong>nil</strong> and an error message if failed. Suspends execution of the calling Lua process if there is no matching receive and the async
 (boolean) flag is not set. The async flag, by default, is not set.</p>

<p> Calling this synchronously from Corona's thread results in an error unless a corresponding send has already fired. As with <a href="api.html#send">send</a>,
 this is usually desired, to avoid Corona blocking; <a href="api.html#receive_allow_from_main">receive_allow_from_main</a> is provided to circumvent this protection.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
        <li><span class="parameter">asynchronous</span>
            <span class="types"><span class="type">bool</span></span>
         Receive asynchronously?
         (<em>default</em> false)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Values passed by <a href="api.html#send">send</a>.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "receive_allow_from_main"></a>
    <strong>receive_allow_from_main ()</strong>
    </dt>
    <dd>
    Variant of <a href="api.html#receive">receive</a> that allows unmatched receives from Corona's thread.






</dd>
    <dt>
    <a name = "newchannel"></a>
    <strong>newchannel (channel_name)</strong>
    </dt>
    <dd>
    Creates a new channel identified by string name.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of new communication channel.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        <strong>true</strong>, indicating success.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>




</dd>
    <dt>
    <a name = "delchannel"></a>
    <strong>delchannel (channel_name)</strong>
    </dt>
    <dd>
    Destroys a channel identified by string name.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.</p>

<p> Lua processes waiting to send or receive messages on destroyed channels have their execution resumed and receive an error
 message indicating the channel was destroyed.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "alert"></a>
    <strong>alert (message, payload)</strong>
    </dt>
    <dd>
    Dispatch an alert event (in the main state), e.g.  to react to something in a process.</p>

<p> Listeners for events named <em>message</em> will be alerted. The event contains <em>payload</em> in field <strong>payload</strong>.</p>

<p> In the main state, this will be performed immediately. Otherwise, alerts will fire during an <strong>enterFrame</strong>; if Lua is
 trying to close, this will do nothing.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">message</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         User-defined message.
        </li>
        <li><span class="parameter">payload</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a>, <span class="type">number</span>, <span class="type">boolean</span> or <span class="type">nil</span></span>
         User-defined payload.
        </li>
    </ul>



    <h3>See also:</h3>
    <ul>
         <a href="api.html#get_alert_dispatcher">get_alert_dispatcher</a>
    </ul>


</dd>
    <dt>
    <a name = "get_alert_dispatcher"></a>
    <strong>get_alert_dispatcher ()</strong>
    </dt>
    <dd>
    Gets the dispatcher used by <a href="api.html#alert">alert</a>, in order to add / remove listeners. </p>

<p> Calling this outside the main state results in an error.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">EventDispatcher</span></span>
        Dispatcher.
    </ol>




</dd>
    <dt>
    <a name = "is_main_state"></a>
    <strong>is_main_state ()</strong>
    </dt>
    <dd>
    Check whether the running process is in the main state.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is this the main state?
    </ol>




</dd>
    <dt>
    <a name = "is_waiting"></a>
    <strong>is_waiting ()</strong>
    </dt>
    <dd>
    Check whether <em>luaproc</em> is waiting for processes to finish, either after a call to <a href="api.html#wait">wait</a> or while closing.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is <em>luaproc</em> waiting?
    </ol>




</dd>
    <dt>
    <a name = "sleep"></a>
    <strong>sleep (ms)</strong>
    </dt>
    <dd>
    Causes the current process to sleep. </p>

<p> Calling this from the main state results in an error.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">ms</span>
            <span class="types"><span class="type">uint</span></span>
         Milliseconds to sleep, &ge; 0.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "wants_to_close"></a>
    <strong>wants_to_close ()</strong>
    </dt>
    <dd>
    Indicates whether Lua wants to close, either from trying to exit the app or Corona simulator, or on account of relaunching the Corona simulator. </p>

<p> <em>luaproc</em> waits for all its processes to finish, rather than kill them outright. Long-running ones should therefore query this from time to time if
 graceful early exits are desired. Furthermore, any infinite loop <strong>must</strong> use this, or Corona will hang on exit.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is Lua trying to close?
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
