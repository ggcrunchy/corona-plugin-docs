<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
   "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<head>
    <title>Documentation</title>
    <link rel="stylesheet" href="../ldoc.css" type="text/css" />
</head>
<body>

<div id="container">

<div id="product">
	<div id="product_logo"></div>
	<div id="product_name"><big><b></b></big></div>
	<div id="product_description"></div>
</div> <!-- id="product" -->


<div id="main">


<!-- Menu -->

<div id="navigation">
<br/>
<h1>luaproc</h1>

<ul>
  <li><a href="../api.html">Index</a></li>
</ul>

<h2>Contents</h2>
<ul>
<li><a href="#Functions">Functions</a></li>
</ul>


<h2>Modules</h2>
<ul class="$(kind=='Topics' and '' or 'nowrap'">
  <li><strong>luaproc</strong></li>
  <li><a href="../modules/plugin.luaproc.ex.html">luaproc.ex</a></li>
</ul>

</div>

<div id="content">

<h1>Module <code>luaproc</code></h1>
<p>Corona binding for <a href="https://github.com/askyrme/luaproc">luaproc</a>, a concurrent programming library for Lua.</p>
<p> <strong>From the project page:</strong></p>

<p> <em>luaproc</em> is a Lua extension library for concurrent programming. This text provides some background information
 and also serves as a reference manual for the library. The library is available under the same <a href="http://www.lua.org/copyright.html">terms and conditions</a>
 as the Lua language, the MIT license. The idea is that if you can use Lua in a project, you should also be able
 to use <em>luaproc</em>.</p>

<p> Lua natively supports cooperative multithreading by means of coroutines. However, coroutines in Lua cannot be
 executed in parallel. <em>luaproc</em> overcomes that restriction by building on the proposal and sample implementation
 presented in <a href="http://www.inf.puc-rio.br/~roberto/pil2">Programming in Lua</a> (chapter 30). It uses coroutines and
 multiple independent states in Lua to implement Lua processes, which are user threads comprised of Lua code that
 have no shared data. Lua processes are executed by workers, which are system threads implemented with POSIX threads
 (pthreads), and thus can run in parallel.</p>

<p> Communication between Lua processes relies exclusively on message passing. Each message can carry a tuple of atomic
 Lua values (strings, numbers, booleans and <strong>nil</strong>). More complex types must be encoded somehow &mdash; for instance
 by using strings of Lua code that when executed return such a type. Message addressing is based on communication
 channels, which are decoupled from Lua processes and must be explicitly created.</p>

<p> Sending a message is always a synchronous operation, i.e., the send operation only returns after a message has been
 received by another Lua process or if an error occurs (such as trying to send a message to a non-existent channel).
 Receiving a message, on the other hand, can be a synchronous or asynchronous operation. In synchronous mode, a call
 to the receive operation only returns after a message has been received or if an error occurs. In asynchronous mode,
 a call to the receive operation returns immediately and indicates if a message was received or not.</p>

<p> If a Lua process tries to send a message to a channel where there are no Lua processes waiting to receive a message,
 its execution is suspended until a matching receive occurs or the channel is destroyed. The same happens if a Lua
 process tries to synchronously receive a message from a channel where there are no Lua processes waiting to send a
 message.</p>

<p> <em>luaproc</em> also offers an optional facility to recycle Lua processes. Recycling consists of reusing states from
 finished Lua processes, instead of destroying them. When recycling is enabled, a new Lua process can be created by
 loading its code in a previously used state from a finished Lua process, instead of creating a new state.</p>

<p> <strong>References</strong></p>

<p> A paper about <em>luaproc</em> &mdash; Exploring Lua for Concurrent Programming &mdash; was published in the Journal of
 Universal Computer Science and is available <a href="http://www.jucs.org/jucs_14_21/exploring_lua_for_concurrent">here</a> and
 <a href="http://www.inf.puc-rio.br/~roberto/docs/ry08-05.pdf">here</a>. Some information in the paper is already outdated, but
 it still provides a good overview of the library and some of its design choices.</p>

<p> A tech report about concurrency in Lua, which uses <em>luaproc</em> as part of a case study, is also available
 <a href="ftp://ftp.inf.puc-rio.br/pub/docs/techreports/11_13_skyrme.pdf">here</a>.</p>

<p> Finally, a paper about an experiment to port <em>luaproc</em> to use Transactional Memory instead of the standard POSIX Threads
 synchronization constructs, published as a part of the 8th ACM SIGPLAN Workshop on Transactional Computing, can be found
 <a href="http://transact2013.cse.lehigh.edu/skyrme.pdf">here</a>.</p>

<p> Copyright Â© 2008-2015 Alexandre Skyrme, Noemi Rodriguez, Roberto Ierusalimschy.
 All rights reserved.</p>


<h2><a href="#Functions">Functions</a></h2>
<table class="function_list">
	<tr>
	<td class="name" nowrap><a href="#newproc">newproc (lua_code)</a></td>
	<td class="summary">Creates a new Lua process to run the specified string of Lua code.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#newproc">newproc (f)</a></td>
	<td class="summary">Variant of <strong>newproc</strong> that accepts a function.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#setnumworkers">setnumworkers (number_of_workers)</a></td>
	<td class="summary">Sets the number of active workers (pthreads) to n (default = 1, minimum = 1).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#getnumworkers">getnumworkers ()</a></td>
	<td class="summary">Returns the number of active workers (pthreads).</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wait">wait ()</a></td>
	<td class="summary">Waits until all Lua processes have finished, then continues program execution.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#recycle">recycle (maxrecycle)</a></td>
	<td class="summary">Sets the maximum number of Lua processes to recycle.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#send">send (channel_name, ...)</a></td>
	<td class="summary">Sends a message (tuple of boolean, <strong>nil</strong>, number or string values) to a channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#receive">receive (channel_name[, asynchronous=false])</a></td>
	<td class="summary">Receives a message (tuple of boolean, <strong>nil</strong>, number or string values) from a channel.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#newchannel">newchannel (channel_name)</a></td>
	<td class="summary">Creates a new channel identified by string name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#delchannel">delchannel (channel_name)</a></td>
	<td class="summary">Destroys a channel identified by string name.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#allow_receive_from_main_state">allow_receive_from_main_state ()</a></td>
	<td class="summary">Allow unmatched receives from Corona's thread, overriding the default protective behavior.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#allow_send_from_main_state">allow_send_from_main_state ()</a></td>
	<td class="summary">Allow unmatched sends from Corona's thread, overriding the default protective behavior.</td>
	</tr>
	<tr>
	<td class="name" nowrap><a href="#wants_to_close">wants_to_close ()</a></td>
	<td class="summary">Indicates whether Lua wants to close, either from trying to exit the app or Corona simulator, or on account of relaunching the Corona simulator.</td>
	</tr>
</table>

<br/>
<br/>


    <h2><a name="Functions"></a>Functions</h2>
    <dl class="function">
    <dt>
    <a name = "newproc"></a>
    <strong>newproc (lua_code)</strong>
    </dt>
    <dd>
    Creates a new Lua process to run the specified string of Lua code.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error
 message if failed. The only libraries loaded in new Lua processes are <em>luaproc</em> itself and the standard Lua base and
 <a href="https://docs.coronalabs.com/api/library/package/index.html">package</a> libraries. The remaining standard Lua libraries (<strong>io</strong>,
 <strong>os</strong>, <strong>table</strong>, <strong>string</strong>, <strong>math</strong>, <strong>debug</strong>, and <strong>coroutine</strong>) are pre-registered and can be loaded with a call to
 the standard Lua function <a href="https://docs.coronalabs.com/api/library/package/require.html">require</a>.</p>

<p> In case modules need to be <strong>require</strong>'d within the process, <a href="../modules/plugin.luaproc.ex.html#newproc">plugin.luaproc.ex.newproc</a> should be called instead, which accepts the
 same argument, i.e. a string or function. This is simply a wrapper around <strong>newproc</strong>, but also captures and installs Corona's
 <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.path">package.path</a> and <a href="http://www.lua.org/manual/5.1/manual.html#pdf-package.cpath">package.cpath</a>,
 so <strong>require</strong>s work as expected.</p>

<p> Note that processes are unique Lua states, so Lua modules loaded in multiple processes, or in one process and Corona's thread,
 will have different contents. In the case of dynamic libraries, when several instances are to be used simultaneously, it is best
 to have an explicit guarantee that the library in question is reentrant, i.e. it keeps no state or all state is kept in manager
 objects that can be isolated to the process.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">lua_code</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         String of Lua code.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">boolean</span></span>
        Creation succeeded?</li>
        <li>
           <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        If creation failed, the error message.</li>
    </ol>




</dd>
    <dt>
    <a name = "newproc"></a>
    <strong>newproc (f)</strong>
    </dt>
    <dd>
    Variant of <strong>newproc</strong> that accepts a function. </p>

<p> Boolean, <strong>nil</strong>, number, and string upvalues will be copied over to this function (at this point, they are their own values).
 Upvalues of any other type will result in an error. Confusingly, this will make the snippet
   local luaproc = require("plugin.luaproc")
   luaproc.newchannel("channel")
   luaproc.newproc(function()</p>
<pre><code> luaproc.send("channel", "ERROR!") -- error: tries to capture luaproc as upvalue
</code></pre>
<p>   end)
 error out. To avoid this, either rename the top-level local or use <a href="../modules/plugin.luaproc.ex.html#newproc">plugin.luaproc.ex.newproc</a>.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">f</span>
            <span class="types"><span class="type">function</span></span>
         Function.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">boolean</span></span>
        Creation succeeded?</li>
        <li>
           <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        If creation failed, the error message.</li>
    </ol>




</dd>
    <dt>
    <a name = "setnumworkers"></a>
    <strong>setnumworkers (number_of_workers)</strong>
    </dt>
    <dd>
    Sets the number of active workers (pthreads) to n (default = 1, minimum = 1). </p>

<p> Creates and destroys workers as needed, depending on the current number of active workers.</p>

<p> No return, raises error if worker could not be created.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">number_of_workers</span>
            <span class="types"><span class="type">int</span></span>
         Number of active workers.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "getnumworkers"></a>
    <strong>getnumworkers ()</strong>
    </dt>
    <dd>
    Returns the number of active workers (pthreads).


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">int</span></span>
        Number of active workers.
    </ol>




</dd>
    <dt>
    <a name = "wait"></a>
    <strong>wait ()</strong>
    </dt>
    <dd>
    Waits until all Lua processes have finished, then continues program execution. </p>

<p> It only makes sense to call this function from the main Lua script, i.e. from Corona's thread. Moreover, this function is
 implicitly called when the main Lua script finishes executing, e.g. on a simulator reset or when the app is about to exit.






</dd>
    <dt>
    <a name = "recycle"></a>
    <strong>recycle (maxrecycle)</strong>
    </dt>
    <dd>
    Sets the maximum number of Lua processes to recycle.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.
 The default number is zero, i.e., no Lua processes are recycled.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">maxrecycle</span>
            <span class="types"><span class="type">int</span></span>
         Maximum number of processes.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">true</span> or <span class="type">nil</span></span>
        Success indicator.</li>
        <li>
           <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        On failure, the error message.</li>
    </ol>




</dd>
    <dt>
    <a name = "send"></a>
    <strong>send (channel_name, ...)</strong>
    </dt>
    <dd>
    Sends a message (tuple of boolean, <strong>nil</strong>, number or string values) to a channel.  Returns <strong>true</strong> if successful or <strong>nil</strong> and
 an error message if failed. Suspends execution of the calling Lua process if there is no matching receive.</p>

<p> Unless explicitly specified otherwise, calling this from Corona's thread results in an error if the channel is not already waiting
 for the results. (This is usually desired, as Corona itself would block otherwise.)

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
        <li><span class="parameter">...</span>
         Values to send, of the above-mentioned types.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">true</span> or <span class="type">nil</span></span>
        Success indicator.</li>
        <li>
           <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        On failure, the error message.</li>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="../modules/luaproc.html#allow_send_from_main_state">allow_send_from_main_state</a>
    </ul>


</dd>
    <dt>
    <a name = "receive"></a>
    <strong>receive (channel_name[, asynchronous=false])</strong>
    </dt>
    <dd>
    Receives a message (tuple of boolean, <strong>nil</strong>, number or string values) from a channel.  Returns received values if successful or
 <strong>nil</strong> and an error message if failed. Suspends execution of the calling Lua process if there is no matching receive and the async
 (boolean) flag is not set. The async flag, by default, is not set.</p>

<p> Unless explicitly specified otherwise, calling this synchronously from Corona's thread results in an error unless a corresponding
 send has already fired. (Again, this is usually desired, since Corona would block otherwise.)

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
        <li><span class="parameter">asynchronous</span>
            <span class="types"><span class="type">bool</span></span>
         Receive asynchronously?
         (<em>default</em> false)
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>

        Values passed by <a href="../modules/luaproc.html#send">send</a>.
    </ol>
     <h3>Or</h3>
    <ol>
        <li>
        <strong>nil</strong>, indicating an error.</li>
        <li>
        Error message, of type <strong>string</strong>.</li>
    </ol>


    <h3>See also:</h3>
    <ul>
         <a href="../modules/luaproc.html#allow_receive_from_main_state">allow_receive_from_main_state</a>
    </ul>


</dd>
    <dt>
    <a name = "newchannel"></a>
    <strong>newchannel (channel_name)</strong>
    </dt>
    <dd>
    Creates a new channel identified by string name.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of new communication channel.
        </li>
    </ul>

    <h3>Returns:</h3>
    <ol>
        <li>
           <span class="types"><span class="type">true</span> or <span class="type">nil</span></span>
        Success indicator.</li>
        <li>
           <span class="types">optional <a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
        On failure, the error message.</li>
    </ol>




</dd>
    <dt>
    <a name = "delchannel"></a>
    <strong>delchannel (channel_name)</strong>
    </dt>
    <dd>
    Destroys a channel identified by string name.  Returns <strong>true</strong> if successful or <strong>nil</strong> and an error message if failed.</p>

<p> Lua processes waiting to send or receive messages on destroyed channels have their execution resumed and receive an error
 message indicating the channel was destroyed.

    <h3>Parameters:</h3>
    <ul>
        <li><span class="parameter">channel_name</span>
            <span class="types"><a class="type" href="http://www.lua.org/manual/5.1/manual.html#5.4">string</a></span>
         Name of communication channel.
        </li>
    </ul>





</dd>
    <dt>
    <a name = "allow_receive_from_main_state"></a>
    <strong>allow_receive_from_main_state ()</strong>
    </dt>
    <dd>
    Allow unmatched receives from Corona's thread, overriding the default protective behavior.




    <h3>See also:</h3>
    <ul>
         <a href="../modules/luaproc.html#receive">receive</a>
    </ul>


</dd>
    <dt>
    <a name = "allow_send_from_main_state"></a>
    <strong>allow_send_from_main_state ()</strong>
    </dt>
    <dd>
    Allow unmatched sends from Corona's thread, overriding the default protective behavior.




    <h3>See also:</h3>
    <ul>
         <a href="../modules/luaproc.html#send">send</a>
    </ul>


</dd>
    <dt>
    <a name = "wants_to_close"></a>
    <strong>wants_to_close ()</strong>
    </dt>
    <dd>
    Indicates whether Lua wants to close, either from trying to exit the app or Corona simulator, or on account of relaunching the Corona simulator. </p>

<p> <em>luaproc</em> waits for all its processes to finish, rather than kill them outright. Thus, long-running ones should query this from time to time to
 gracefully quit early. Furthermore, any infinite loop <strong>must</strong> use this, or Corona will hang on exit.


    <h3>Returns:</h3>
    <ol>

           <span class="types"><span class="type">boolean</span></span>
        Is Lua trying to close?
    </ol>




</dd>
</dl>


</div> <!-- id="content" -->
</div> <!-- id="main" -->
<div id="about">
<i>generated by <a href="http://github.com/stevedonovan/LDoc">LDoc 1.4.0</a></i>
</div> <!-- id="about" -->
</div> <!-- id="container" -->
</body>
</html>
